{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django REST - Access Policy \u00b6 This project brings a declaritive, organized approach to managing access control in Django REST Framework projects. Each ViewSet or function-based view can be assigned an explicit policy for the exposed resources. No more digging through views or seralizers to understand access logic -- it's all in one place in a format that less technical stakeholders can understand. If you're familiar with other declaritive access models, such as AWS' IAM, the syntax will be familiar. In short, you can express access rules like this: class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" , \"unpublish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" } ] Key Features: A declarative JSON syntax makes access rules easy to understand, reducing the chance of accidental exposure The option to load access statements from an external source means non-programmers can edit access policies without redeployments Write plain Python methods that examine every facet of the current request (user, data, model instance) for more granular, contextual access rules Keep all your access logic in one place: add scope_queryset methods to access policy classes to apply filtering for multitenant databases 1.0 Breaking Change See migration notes if your policy statements combine multiple conditions into boolean expressions. Requirements \u00b6 Python 3.5+ Installation \u00b6 pip install drf-access-policy Quick Example \u00b6 To define a policy, import AccessPolicy and subclass it: from rest_framework.viewsets import ModelViewSet from rest_access_policy import AccessPolicy class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" , \"unpublish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" } ] class ArticleViewSet ( ModelViewSet ): permission_classes = ( ArticleAccessPolicy , ) You'll probably have a single access policy per view set, so a mixin is also provided to make this more explicit: from rest_access_policy import AccessViewSetMixin class ArticleViewSet ( AccessViewSetMixin , ModelViewSet ): access_policy = ArticleAccessPolicy The mixin will ensure that the access_policy is set and automatically add it to the view's permission_classes so that DRF's request handler evaluates it. Read on for a full example of how to add an access policy to a ViewSet .","title":"Intro"},{"location":"#django-rest-access-policy","text":"This project brings a declaritive, organized approach to managing access control in Django REST Framework projects. Each ViewSet or function-based view can be assigned an explicit policy for the exposed resources. No more digging through views or seralizers to understand access logic -- it's all in one place in a format that less technical stakeholders can understand. If you're familiar with other declaritive access models, such as AWS' IAM, the syntax will be familiar. In short, you can express access rules like this: class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" , \"unpublish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" } ] Key Features: A declarative JSON syntax makes access rules easy to understand, reducing the chance of accidental exposure The option to load access statements from an external source means non-programmers can edit access policies without redeployments Write plain Python methods that examine every facet of the current request (user, data, model instance) for more granular, contextual access rules Keep all your access logic in one place: add scope_queryset methods to access policy classes to apply filtering for multitenant databases 1.0 Breaking Change See migration notes if your policy statements combine multiple conditions into boolean expressions.","title":"Django REST - Access Policy"},{"location":"#requirements","text":"Python 3.5+","title":"Requirements"},{"location":"#installation","text":"pip install drf-access-policy","title":"Installation"},{"location":"#quick-example","text":"To define a policy, import AccessPolicy and subclass it: from rest_framework.viewsets import ModelViewSet from rest_access_policy import AccessPolicy class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" , \"unpublish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" } ] class ArticleViewSet ( ModelViewSet ): permission_classes = ( ArticleAccessPolicy , ) You'll probably have a single access policy per view set, so a mixin is also provided to make this more explicit: from rest_access_policy import AccessViewSetMixin class ArticleViewSet ( AccessViewSetMixin , ModelViewSet ): access_policy = ArticleAccessPolicy The mixin will ensure that the access_policy is set and automatically add it to the view's permission_classes so that DRF's request handler evaluates it. Read on for a full example of how to add an access policy to a ViewSet .","title":"Quick Example"},{"location":"customization/","text":"Customizing User Group/Role Values \u00b6 If you aren't using Django's built-in auth app, you may need to define a custom way to retrieve the role/group names to which the user belongs. Just define a method called get_user_group_values on your policy class. It is passed a single argument: the user of the current request. In the example below, the user model has a to-many relationship with a \"roles\", which have their \"name\" value in a field called \"title\". class UserAccessPolicy ( AccessPolicy ): # ... other properties and methods ... def get_user_group_values ( self , user ) -> List [ str ]: return list ( user . roles . values_list ( \"title\" , flat = True )) Customizing Principal Prefixes \u00b6 By default, the prefixes to identify the type of principle (user or group) are \"id:\" and \"group:\", respectively. You can customize this by setting these properties on your policy class: class FriendRequestPolicy ( permissions . BasePermission ): group_prefix = \"role:\" id_prefix = \"staff_id:\" # .. the rest of you policy definition ..","title":"Customizing"},{"location":"customization/#customizing-user-grouprole-values","text":"If you aren't using Django's built-in auth app, you may need to define a custom way to retrieve the role/group names to which the user belongs. Just define a method called get_user_group_values on your policy class. It is passed a single argument: the user of the current request. In the example below, the user model has a to-many relationship with a \"roles\", which have their \"name\" value in a field called \"title\". class UserAccessPolicy ( AccessPolicy ): # ... other properties and methods ... def get_user_group_values ( self , user ) -> List [ str ]: return list ( user . roles . values_list ( \"title\" , flat = True ))","title":"Customizing User Group/Role Values"},{"location":"customization/#customizing-principal-prefixes","text":"By default, the prefixes to identify the type of principle (user or group) are \"id:\" and \"group:\", respectively. You can customize this by setting these properties on your policy class: class FriendRequestPolicy ( permissions . BasePermission ): group_prefix = \"role:\" id_prefix = \"staff_id:\" # .. the rest of you policy definition ..","title":"Customizing Principal Prefixes"},{"location":"field_level_permissions/","text":"Field-Level Permissions \u00b6 Often, depending on the user, not all fields should be visible or only a subset should be writable. For these scenarios, you can define a scope_fields method on the access policy which is passed the dict of name:Field pairs from a serializer used with the FieldAccessMixin . Scenario: A field should only exist for admin users \u00b6 Requirement: When a customer account is serialized or deserialized, the email field should only be present if the user is an admin. You could define a scope_fields method on the access policy like this: class CustomerAccountAccessPolicy ( AccessPolicy ): statements = [ # statements that define who is allowed to perform what action ] @classmethod def scope_fields ( cls , request , fields : dict , instance = None ) -> dict : if not request . user . is_admin (): fields . pop ( 'email' , None ) return fields Make sure to add the FieldAccessMixin to your serializer and assign it the correct access policy in its Meta class: from rest_access_policy import FieldAccessMixin class CustomerAccountSerializer ( FieldAccessMixin , serializers . ModelSerializer ): class Meta : model = UserAccount fields = [ \"username\" , \"first_name\" , \"last_name\" , \"email\" ] access_policy = CustomerAccountAccessPolicy Scenario: A field should be read-only, except for the author \u00b6 Requirement: When a request is made to update an article, the content field should be read-only, except for the author. You could define a scope_fields method on the access policy like this: class CustomerAccountAccessPolicy ( AccessPolicy ): statements = [ # statements that define who is allowed to perform what action ] @classmethod def scope_fields ( cls , request , fields : dict , instance = None ) -> dict : if instance and instance . author != request . user : fields [ \"content\" ] . read_only = True return fields As before, make sure to add the FieldAccessMixin to your serializer and assign it the correct access policy in its Meta class.","title":"Field-Level Permissions"},{"location":"field_level_permissions/#field-level-permissions","text":"Often, depending on the user, not all fields should be visible or only a subset should be writable. For these scenarios, you can define a scope_fields method on the access policy which is passed the dict of name:Field pairs from a serializer used with the FieldAccessMixin .","title":"Field-Level Permissions"},{"location":"field_level_permissions/#scenario-a-field-should-only-exist-for-admin-users","text":"Requirement: When a customer account is serialized or deserialized, the email field should only be present if the user is an admin. You could define a scope_fields method on the access policy like this: class CustomerAccountAccessPolicy ( AccessPolicy ): statements = [ # statements that define who is allowed to perform what action ] @classmethod def scope_fields ( cls , request , fields : dict , instance = None ) -> dict : if not request . user . is_admin (): fields . pop ( 'email' , None ) return fields Make sure to add the FieldAccessMixin to your serializer and assign it the correct access policy in its Meta class: from rest_access_policy import FieldAccessMixin class CustomerAccountSerializer ( FieldAccessMixin , serializers . ModelSerializer ): class Meta : model = UserAccount fields = [ \"username\" , \"first_name\" , \"last_name\" , \"email\" ] access_policy = CustomerAccountAccessPolicy","title":"Scenario: A field should only exist for admin users"},{"location":"field_level_permissions/#scenario-a-field-should-be-read-only-except-for-the-author","text":"Requirement: When a request is made to update an article, the content field should be read-only, except for the author. You could define a scope_fields method on the access policy like this: class CustomerAccountAccessPolicy ( AccessPolicy ): statements = [ # statements that define who is allowed to perform what action ] @classmethod def scope_fields ( cls , request , fields : dict , instance = None ) -> dict : if instance and instance . author != request . user : fields [ \"content\" ] . read_only = True return fields As before, make sure to add the FieldAccessMixin to your serializer and assign it the correct access policy in its Meta class.","title":"Scenario: A field should be read-only, except for the author"},{"location":"license/","text":"MIT License Copyright \u00a9 2019 Robert Singer Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"loading_external_source/","text":"Loading Statements from External Source \u00b6 If you don't want your policy statements hardcoded into the classes, you can load them from an external data source: a great step because you can change access rules without redeploying code. Just define a method on your policy class called get_policy_statements , which has the following signature: get_policy_statements(self, request, view) -> List[dict] Example: class UserAccessPolicy ( AccessPolicy ): id = 'user-policy' def get_policy_statements ( self , request , view ) -> List [ dict ]: statements = data_api . load_json ( self . id ) return json . loads ( statements ) You probably want to only define this method once on your own custom subclass of AccessPolicy , from which all your other access policies inherit.","title":"Loading External Statements"},{"location":"loading_external_source/#loading-statements-from-external-source","text":"If you don't want your policy statements hardcoded into the classes, you can load them from an external data source: a great step because you can change access rules without redeploying code. Just define a method on your policy class called get_policy_statements , which has the following signature: get_policy_statements(self, request, view) -> List[dict] Example: class UserAccessPolicy ( AccessPolicy ): id = 'user-policy' def get_policy_statements ( self , request , view ) -> List [ dict ]: statements = data_api . load_json ( self . id ) return json . loads ( statements ) You probably want to only define this method once on your own custom subclass of AccessPolicy , from which all your other access policies inherit.","title":"Loading Statements from External Source"},{"location":"migration_notes/","text":"Migrating to 1.0 \u00b6 The 1.0 version introduced a breaking change for projects that use the condition element to combine multiple condition methods with boolean logic. Projects that use the condition element in this way must update affected statements to use the condition_expression element instead, which evaluates expressions in the same way that occurred prior to 1.0. No longer works class EmailAccountAccessPolicy ( AccessPolicy ): statements = [ { \"principal\" : \"authenticated\" , \"action\" : \"read\" , \"effect\" : \"allow\" , \"condition\" : \"is_owner or is_NSA\" }, ] Change to class EmailAccountAccessPolicy ( AccessPolicy ): statements = [ { \"principal\" : \"authenticated\" , \"action\" : \"read\" , \"effect\" : \"allow\" , \"condition_expression\" : \"is_owner or is_NSA\" }, ]","title":"Migrating"},{"location":"migration_notes/#migrating-to-10","text":"The 1.0 version introduced a breaking change for projects that use the condition element to combine multiple condition methods with boolean logic. Projects that use the condition element in this way must update affected statements to use the condition_expression element instead, which evaluates expressions in the same way that occurred prior to 1.0. No longer works class EmailAccountAccessPolicy ( AccessPolicy ): statements = [ { \"principal\" : \"authenticated\" , \"action\" : \"read\" , \"effect\" : \"allow\" , \"condition\" : \"is_owner or is_NSA\" }, ] Change to class EmailAccountAccessPolicy ( AccessPolicy ): statements = [ { \"principal\" : \"authenticated\" , \"action\" : \"read\" , \"effect\" : \"allow\" , \"condition_expression\" : \"is_owner or is_NSA\" }, ]","title":"Migrating to 1.0"},{"location":"multi_tenacy/","text":"Multitenancy Data / Restricting QuerySets \u00b6 You can define a class method on your policy class that takes a QuerySet and the current request and returns a securely scoped QuerySet representing only the database rows the current user should have access to. This is helpful for multitenant situations or more generally when users should not have full visibility to model instances. You could do this elsewhere in your code, but putting this method on the policy class keeps all access logic in a single place. class PhotoAlbumAccessPolicy ( AccessPolicy ): # ... statements, etc ... # Users can only access albums they have created @classmethod def scope_queryset ( cls , request , qs ): return qs . filter ( creator = request . user ) class TodoListAccessPolicy ( AccessPolicy ): # ... statements, etc ... # Users can only access todo lists owned by their organization @classmethod def scope_queryset ( cls , request , qs ): user_orgs = request . user . organizations . all () return qs . filter ( org__id__in = user_orgs ) You have to remember to call scope_queryset method from the view, so I'd suggest reviewing this as part of a security audit checklist. class PhotoAlbumViewSet ( ModelViewSet ): # ... # Ensure that current user only access albums created by himself def get_queryset ( self ): return self . access_policy . scope_queryset ( self . request , PhotoAlbum . objects . all () )","title":"Multitenancy/Scoping QuerySets"},{"location":"multi_tenacy/#multitenancy-data-restricting-querysets","text":"You can define a class method on your policy class that takes a QuerySet and the current request and returns a securely scoped QuerySet representing only the database rows the current user should have access to. This is helpful for multitenant situations or more generally when users should not have full visibility to model instances. You could do this elsewhere in your code, but putting this method on the policy class keeps all access logic in a single place. class PhotoAlbumAccessPolicy ( AccessPolicy ): # ... statements, etc ... # Users can only access albums they have created @classmethod def scope_queryset ( cls , request , qs ): return qs . filter ( creator = request . user ) class TodoListAccessPolicy ( AccessPolicy ): # ... statements, etc ... # Users can only access todo lists owned by their organization @classmethod def scope_queryset ( cls , request , qs ): user_orgs = request . user . organizations . all () return qs . filter ( org__id__in = user_orgs ) You have to remember to call scope_queryset method from the view, so I'd suggest reviewing this as part of a security audit checklist. class PhotoAlbumViewSet ( ModelViewSet ): # ... # Ensure that current user only access albums created by himself def get_queryset ( self ): return self . access_policy . scope_queryset ( self . request , PhotoAlbum . objects . all () )","title":"Multitenancy Data / Restricting QuerySets"},{"location":"object_level_permissions/","text":"Object-Level Permissions/Custom Conditions \u00b6 What about object-level permissions? You can easily check object-level access in a custom condition that's evaluated to determine whether the statement takes effect. This condition is passed the view instance, so you can get the model instance with a call to view.get_object() . You can even reference multiple conditions, to keep your access methods focused and testable, as well as parametrize these conditions with arguments. class AccountAccessPolicy ( AccessPolicy ): statements = [ ## ... other statements ... { \"action\" : [ \"withdraw\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition\" : [ \"balance_is_positive\" , \"user_must_be:owner\" ] }, { \"action\" : [ \"upgrade_to_gold_status\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition\" : [ \"user_must_be:account_advisor\" ] } ## ... other statements ... ] def balance_is_positive ( self , request , view , action ) -> bool : account = view . get_object () return account . balance > 0 def user_must_be ( self , request , view , action , field : str ) -> bool : account = view . get_object () return getattr ( account , field ) == request . user Notice how we're re-using the user_must_be method by parameterizing it with the model field that should be equal for the user of the request: the statement will only be effective if this condition passes. If you have multiple custom methods defined on the policy, you can construct boolean expressions to combine them. The syntax is the same as Python's boolean expressions. Note that the condition_expression element is used instead of condition . class AccountAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"freeze\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition_expression\" : [ \"(is_request_from_account_owner or is_FBI_request)\" ] }, ] def is_FBI_request ( self , request , view , action ) -> bool : return is_request_from_fbi ( request ) def is_request_from_account_owner ( self , request , view , action ) -> bool : return account . owner == request . user","title":"Custom/Object-Level Conditions"},{"location":"object_level_permissions/#object-level-permissionscustom-conditions","text":"What about object-level permissions? You can easily check object-level access in a custom condition that's evaluated to determine whether the statement takes effect. This condition is passed the view instance, so you can get the model instance with a call to view.get_object() . You can even reference multiple conditions, to keep your access methods focused and testable, as well as parametrize these conditions with arguments. class AccountAccessPolicy ( AccessPolicy ): statements = [ ## ... other statements ... { \"action\" : [ \"withdraw\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition\" : [ \"balance_is_positive\" , \"user_must_be:owner\" ] }, { \"action\" : [ \"upgrade_to_gold_status\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition\" : [ \"user_must_be:account_advisor\" ] } ## ... other statements ... ] def balance_is_positive ( self , request , view , action ) -> bool : account = view . get_object () return account . balance > 0 def user_must_be ( self , request , view , action , field : str ) -> bool : account = view . get_object () return getattr ( account , field ) == request . user Notice how we're re-using the user_must_be method by parameterizing it with the model field that should be equal for the user of the request: the statement will only be effective if this condition passes. If you have multiple custom methods defined on the policy, you can construct boolean expressions to combine them. The syntax is the same as Python's boolean expressions. Note that the condition_expression element is used instead of condition . class AccountAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"freeze\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition_expression\" : [ \"(is_request_from_account_owner or is_FBI_request)\" ] }, ] def is_FBI_request ( self , request , view , action ) -> bool : return is_request_from_fbi ( request ) def is_request_from_account_owner ( self , request , view , action ) -> bool : return account . owner == request . user","title":"Object-Level Permissions/Custom Conditions"},{"location":"policy_logic/","text":"Policy Evaluation Logic \u00b6 To determine whether access to a request is granted, two steps are applied: (1) filtering statements , to find out which statements apply to the request (2) denying or allowing the request based on those statements. Filtering statements : A statement is applicable to the current request if all of the following are true (a) the request user matches one of the statement's principals, (b) the name of the method/function matches one of its actions, and (c) all custom conditions evaluate to true. Allow or deny : The request is allowed if any of the statements have an effect of \"allow\", and none have an effect of \"deny\". By default, all requests are denied. Requests are implicitly denied if no Allow statements are found, and they are explicitly denied if any Deny statements are found. Deny statements trump Allow statements. Example \u00b6 Consider the following access policy and ViewSet . class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" } ] class ArticleViewSet ( ModelViewSet ): permission_classes = ( ArticleAccessPolicy , ) @action ( method = \"POST\" ) def publish ( self , request , * args , ** kwargs ): pass A user in the group sales is allowed to list and retrieve articles because of the first statement. They cannot publish because all access is implicitly denied, however users in the group editor can publish due to the second statement.","title":"Policy Evaluation Logic"},{"location":"policy_logic/#policy-evaluation-logic","text":"To determine whether access to a request is granted, two steps are applied: (1) filtering statements , to find out which statements apply to the request (2) denying or allowing the request based on those statements. Filtering statements : A statement is applicable to the current request if all of the following are true (a) the request user matches one of the statement's principals, (b) the name of the method/function matches one of its actions, and (c) all custom conditions evaluate to true. Allow or deny : The request is allowed if any of the statements have an effect of \"allow\", and none have an effect of \"deny\". By default, all requests are denied. Requests are implicitly denied if no Allow statements are found, and they are explicitly denied if any Deny statements are found. Deny statements trump Allow statements.","title":"Policy Evaluation Logic"},{"location":"policy_logic/#example","text":"Consider the following access policy and ViewSet . class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" } ] class ArticleViewSet ( ModelViewSet ): permission_classes = ( ArticleAccessPolicy , ) @action ( method = \"POST\" ) def publish ( self , request , * args , ** kwargs ): pass A user in the group sales is allowed to list and retrieve articles because of the first statement. They cannot publish because all access is implicitly denied, however users in the group editor can publish due to the second statement.","title":"Example"},{"location":"policy_reuse/","text":"Access Policy Re-Use \u00b6 If you've defined a scope_queryset method, you'll likely want to use it in multiple places. If an object shouldn't be returned to a user from a view set, they probably shouldn't be able to reference that object's id when sending a POST or PUT request. A PermittedPkRelatedField can be passed an access policy class. from django.contrib.auth.models import User from rest_framework import serializers from rest_access_policy import PermittedPkRelatedField from my_policies import UserAccessPolicy class AccountUpdateSerializer ( serializers . ModelSerializesr ): emergency_contact = PermittedPkRelatedField ( access_policy = UserAccessPolicy , queryset = User . objects . all () ) Ensure that when the serializer is instantiated, it gets passed the request object, which gets passed to the policy's scope_queryset behind the scenes.","title":"Policy Re-Use"},{"location":"policy_reuse/#access-policy-re-use","text":"If you've defined a scope_queryset method, you'll likely want to use it in multiple places. If an object shouldn't be returned to a user from a view set, they probably shouldn't be able to reference that object's id when sending a POST or PUT request. A PermittedPkRelatedField can be passed an access policy class. from django.contrib.auth.models import User from rest_framework import serializers from rest_access_policy import PermittedPkRelatedField from my_policies import UserAccessPolicy class AccountUpdateSerializer ( serializers . ModelSerializesr ): emergency_contact = PermittedPkRelatedField ( access_policy = UserAccessPolicy , queryset = User . objects . all () ) Ensure that when the serializer is instantiated, it gets passed the request object, which gets passed to the policy's scope_queryset behind the scenes.","title":"Access Policy Re-Use"},{"location":"reusable_conditions/","text":"Re-Usable Conditions/Permissions \u00b6 If you'd like to re-use custom conditions across policies, you can define them globally in a module and point to it via the setttings. You can also provide a List of paths to check multiple files. # in your project settings.py DRF_ACCESS_POLICY = { \"reusable_conditions\" : [ \"myproject.global_access_conditions\" ]} # in myproject.global_access_conditions.py def is_the_weather_nice ( request , view , action : str ) -> bool : data = weather_api . load_today () return data [ \"temperature\" ] > 68 def user_must_be ( self , request , view , action , field : str ) -> bool : account = view . get_object () return getattr ( account , field ) == request . user The policy class will first check its own methods for what's been defined in the condition property. If nothing is found, it will check the module defined in the reusable_conditions setting.","title":"Reuse Conditions/Permissions"},{"location":"reusable_conditions/#re-usable-conditionspermissions","text":"If you'd like to re-use custom conditions across policies, you can define them globally in a module and point to it via the setttings. You can also provide a List of paths to check multiple files. # in your project settings.py DRF_ACCESS_POLICY = { \"reusable_conditions\" : [ \"myproject.global_access_conditions\" ]} # in myproject.global_access_conditions.py def is_the_weather_nice ( request , view , action : str ) -> bool : data = weather_api . load_today () return data [ \"temperature\" ] > 68 def user_must_be ( self , request , view , action , field : str ) -> bool : account = view . get_object () return getattr ( account , field ) == request . user The policy class will first check its own methods for what's been defined in the condition property. If nothing is found, it will check the module defined in the reusable_conditions setting.","title":"Re-Usable Conditions/Permissions"},{"location":"statement_elements/","text":"Statement Elements \u00b6 JSON policies are made up of elements that together determine who can do what with your application and under what conditions . principal \u00b6 Description Should match the user of the current request by identifying a group they belong to or their user ID. Special Values \"*\" (any user) \"admin\" (any admin user) \"staff\" (any staff user) \"authenticated\" (any authenticated user) \"anonymous\" (any non-authenticated user) Type Union[str, List[str]] Formats Match by group with \"group:{name}\" Match by ID with \"id:{id}\" Examples [\"group:admins\", \"id:9322\"] [\"id:5352\"] [\"anonymous\"] \"*\" action \u00b6 Description The action or actions that the statement applies to. The value should match the name of a view set method or the name of the view function. Alternatively, you can use placeholders to match the current request's HTTP method. Type Union[str, List[str]] Special Values \"*\" (any action) \"<safe_methods>\" (a read-only HTTP request: HEAD, GET, OPTIONS) \"<method:get|head|options|delete|put|patch|post>\" (match a specific HTTP method) Examples [\"list\", \"destroy\", \"create] [\"*\"] [\"<safe_methods>\"] [\"<method:post>\"] effect \u00b6 Description Whether the statement, if it is in effect, should allow or deny access. All access is denied by default, so use deny when you'd like to override an allow statement that will also be in effect. Type str Values \"allow\" \"deny\" condition \u00b6 Description The name of a method on the policy that returns a boolean. If you want to pass a custom argument to the condition's method, format the value as {method_name}:{value} , e.g. user_must_be:owner will call a method named user_must_be , passing it the string \"owner\" as the final argument. The method signature is condition(request, view, action: str, custom_arg: str=None) . If it returns True , the statement will be in effect. Useful for enforcing object-level permissions. If list of conditions is given, all conditions must evaluate to True . Type Union[str, List[str]] Examples \"is_manager_of_account\" \"is_author_of_post\" [\"balance_is_positive\", \"account_is_not_frozen\"]` \"user_must_be:account_manager\" condition_expression \u00b6 Description Same as the condition element, but with added support for evaluating boolean combinations of policy methods. The expressions follow Python's boolean syntax. The method signature is condition(request, view, action: str, custom_arg: str=None) . If it returns True , the statement will be in effect. Type Union[str, List[str]] Examples [\"(is_request_from_account_owner or is_FBI_request)\"] \"is_sunny and is_weekend\" \"is_tasty and not is_expensive\"","title":"Statement Elements"},{"location":"statement_elements/#statement-elements","text":"JSON policies are made up of elements that together determine who can do what with your application and under what conditions .","title":"Statement Elements"},{"location":"statement_elements/#principal","text":"Description Should match the user of the current request by identifying a group they belong to or their user ID. Special Values \"*\" (any user) \"admin\" (any admin user) \"staff\" (any staff user) \"authenticated\" (any authenticated user) \"anonymous\" (any non-authenticated user) Type Union[str, List[str]] Formats Match by group with \"group:{name}\" Match by ID with \"id:{id}\" Examples [\"group:admins\", \"id:9322\"] [\"id:5352\"] [\"anonymous\"] \"*\"","title":"principal"},{"location":"statement_elements/#action","text":"Description The action or actions that the statement applies to. The value should match the name of a view set method or the name of the view function. Alternatively, you can use placeholders to match the current request's HTTP method. Type Union[str, List[str]] Special Values \"*\" (any action) \"<safe_methods>\" (a read-only HTTP request: HEAD, GET, OPTIONS) \"<method:get|head|options|delete|put|patch|post>\" (match a specific HTTP method) Examples [\"list\", \"destroy\", \"create] [\"*\"] [\"<safe_methods>\"] [\"<method:post>\"]","title":"action"},{"location":"statement_elements/#effect","text":"Description Whether the statement, if it is in effect, should allow or deny access. All access is denied by default, so use deny when you'd like to override an allow statement that will also be in effect. Type str Values \"allow\" \"deny\"","title":"effect"},{"location":"statement_elements/#condition","text":"Description The name of a method on the policy that returns a boolean. If you want to pass a custom argument to the condition's method, format the value as {method_name}:{value} , e.g. user_must_be:owner will call a method named user_must_be , passing it the string \"owner\" as the final argument. The method signature is condition(request, view, action: str, custom_arg: str=None) . If it returns True , the statement will be in effect. Useful for enforcing object-level permissions. If list of conditions is given, all conditions must evaluate to True . Type Union[str, List[str]] Examples \"is_manager_of_account\" \"is_author_of_post\" [\"balance_is_positive\", \"account_is_not_frozen\"]` \"user_must_be:account_manager\"","title":"condition"},{"location":"statement_elements/#condition_expression","text":"Description Same as the condition element, but with added support for evaluating boolean combinations of policy methods. The expressions follow Python's boolean syntax. The method signature is condition(request, view, action: str, custom_arg: str=None) . If it returns True , the statement will be in effect. Type Union[str, List[str]] Examples [\"(is_request_from_account_owner or is_FBI_request)\"] \"is_sunny and is_weekend\" \"is_tasty and not is_expensive\"","title":"condition_expression"},{"location":"view_set_mixin/","text":"ViewSet Mixin \u00b6 Most likely, you'll only have one access policy per ViewSet , to keep all the logic in one place for each resource. Django REST Framework allows setting multiple permission classes, which can make ViewSet code less clear. For clarity, a mixin is provided that allows you define to an access_policy class attribute. The mixin will add the policy class to the view's permission_classes to ensure DRF's request handler evaluates it. from my_app_policies import ArticleAccessPolicy from rest_access_policy import AccessViewSetMixin class ArticleViewSet ( AccessViewSetMixin , ModelViewSet ): access_policy = ArticleAccessPolicy def get_queryset ( self ): return self . access_policy . scope_queryset ( self . request , Articles . objects . all () )","title":"ViewSet Mixin"},{"location":"view_set_mixin/#viewset-mixin","text":"Most likely, you'll only have one access policy per ViewSet , to keep all the logic in one place for each resource. Django REST Framework allows setting multiple permission classes, which can make ViewSet code less clear. For clarity, a mixin is provided that allows you define to an access_policy class attribute. The mixin will add the policy class to the view's permission_classes to ensure DRF's request handler evaluates it. from my_app_policies import ArticleAccessPolicy from rest_access_policy import AccessViewSetMixin class ArticleViewSet ( AccessViewSetMixin , ModelViewSet ): access_policy = ArticleAccessPolicy def get_queryset ( self ): return self . access_policy . scope_queryset ( self . request , Articles . objects . all () )","title":"ViewSet Mixin"},{"location":"usage/function_based_view_usage/","text":"Policy for Function-Based View \u00b6 You can also use policies with function-based views. The action to reference in your policy statements is the name of the function. You can also bundle multiple functions into the same policy as the example below shows. class AuditLogsAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"search_logs\" ], \"principal\" : \"group:it_staff\" , \"effect\" : \"allow\" }, { \"action\" : [ \"download_logs\" ], \"principal\" : [ \"group:it_admin\" ], \"effect\" : \"allow\" } ] @api_view ([ \"GET\" ]) @permission_classes (( AuditLogsAccessPolicy ,)) def search_logs ( request ): ## your logic here... pass @api_view ([ \"GET\" ]) @permission_classes (( AuditLogsAccessPolicy ,)) def download_logs ( request ): ## your logic here... pass","title":"Usage - Function-Based Views"},{"location":"usage/function_based_view_usage/#policy-for-function-based-view","text":"You can also use policies with function-based views. The action to reference in your policy statements is the name of the function. You can also bundle multiple functions into the same policy as the example below shows. class AuditLogsAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"search_logs\" ], \"principal\" : \"group:it_staff\" , \"effect\" : \"allow\" }, { \"action\" : [ \"download_logs\" ], \"principal\" : [ \"group:it_admin\" ], \"effect\" : \"allow\" } ] @api_view ([ \"GET\" ]) @permission_classes (( AuditLogsAccessPolicy ,)) def search_logs ( request ): ## your logic here... pass @api_view ([ \"GET\" ]) @permission_classes (( AuditLogsAccessPolicy ,)) def download_logs ( request ): ## your logic here... pass","title":"Policy for Function-Based View"},{"location":"usage/view_set_usage/","text":"Policy for ViewSet \u00b6 A policy is comprised of \"statements\" that declare what \"actions\" a \"principal\" can or cannot perform on the resource, with optional custom checks that can examine any detail of the current request. Two key points to remember going forward: all access is implicitly denied by default any statement with the \"deny\" effect overrides any and all \"allow\" statement Let's look at the policy below, which is for an articles endpoint exposed through a ViewSet . class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" , \"unpublish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" }, { \"action\" : [ \"destroy\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition\" : \"is_author\" }, { \"action\" : [ \"*\" ], \"principal\" : [ \"*\" ], \"effect\" : \"deny\" , \"condition\" : \"is_happy_hour\" } ] def is_author ( self , request , view , action ) -> bool : article = view . get_object () return request . user == article . author def is_happy_hour ( self , request , view , action ) -> bool : now = datetime . datetime . now () return now . hour >= 17 and now . hour <= 18 : @classmethod def scope_queryset ( cls , request , queryset ): if request . user . groups . filter ( name = 'editor' ) . exists (): return queryset return queryset . filter ( status = 'published' ) The actions correspond to the names of methods on the ViewSet and the following rules are put in place: anyone is allowed to list and retrieve articles users in the editor group are allowed to publish and unpublish articles in order to destroy an article, the user must be the author of the article. Notice how the condition method is_author calls get_object() on the view to get the current article. if the condition is_happy_hour , evaluates to True , then no one is allowed to do anything. Additionally, we have some logic in the scope_queryset method for filtering which models are visible to the current user. Here, we want users to only see published articles, unless they are an editor, in which case they can see articles with any status. You have to remember to call this method from the view, so I'd suggest reviewing this as part of a security audit checklist. Below is a ViewSet with the policy attached. Notice how the publish and unpublish methods correspond to the action declarations in the policy. class ArticleViewSet ( AccessViewSetMixin , ModelViewSet ): access_policy = ArticleAccessPolicy # If you prefer not to use the mixin, the policy class can be added to permission_classes # permission_classes = (ArticleAccessPolicy,) # Helper property here to make get_queryset logic # more explicit @property def access_policy ( self ): return self . permission_classes [ 0 ] # Ensure that current user can only see the models # they are allowed to see def get_queryset ( self ): return self . access_policy . scope_queryset ( self . request , Articles . objects . all () ) @action ( methods = [ 'POST' ], detail = False ) def publish ( self , request , * args , ** kwargs ): pass @action ( methods = [ 'POST' ], detail = False ) def unpublish ( self , request , * args , ** kwargs ): pass # the rest of you view set definition...","title":"Usage - ViewSets"},{"location":"usage/view_set_usage/#policy-for-viewset","text":"A policy is comprised of \"statements\" that declare what \"actions\" a \"principal\" can or cannot perform on the resource, with optional custom checks that can examine any detail of the current request. Two key points to remember going forward: all access is implicitly denied by default any statement with the \"deny\" effect overrides any and all \"allow\" statement Let's look at the policy below, which is for an articles endpoint exposed through a ViewSet . class ArticleAccessPolicy ( AccessPolicy ): statements = [ { \"action\" : [ \"list\" , \"retrieve\" ], \"principal\" : \"*\" , \"effect\" : \"allow\" }, { \"action\" : [ \"publish\" , \"unpublish\" ], \"principal\" : [ \"group:editor\" ], \"effect\" : \"allow\" }, { \"action\" : [ \"destroy\" ], \"principal\" : [ \"*\" ], \"effect\" : \"allow\" , \"condition\" : \"is_author\" }, { \"action\" : [ \"*\" ], \"principal\" : [ \"*\" ], \"effect\" : \"deny\" , \"condition\" : \"is_happy_hour\" } ] def is_author ( self , request , view , action ) -> bool : article = view . get_object () return request . user == article . author def is_happy_hour ( self , request , view , action ) -> bool : now = datetime . datetime . now () return now . hour >= 17 and now . hour <= 18 : @classmethod def scope_queryset ( cls , request , queryset ): if request . user . groups . filter ( name = 'editor' ) . exists (): return queryset return queryset . filter ( status = 'published' ) The actions correspond to the names of methods on the ViewSet and the following rules are put in place: anyone is allowed to list and retrieve articles users in the editor group are allowed to publish and unpublish articles in order to destroy an article, the user must be the author of the article. Notice how the condition method is_author calls get_object() on the view to get the current article. if the condition is_happy_hour , evaluates to True , then no one is allowed to do anything. Additionally, we have some logic in the scope_queryset method for filtering which models are visible to the current user. Here, we want users to only see published articles, unless they are an editor, in which case they can see articles with any status. You have to remember to call this method from the view, so I'd suggest reviewing this as part of a security audit checklist. Below is a ViewSet with the policy attached. Notice how the publish and unpublish methods correspond to the action declarations in the policy. class ArticleViewSet ( AccessViewSetMixin , ModelViewSet ): access_policy = ArticleAccessPolicy # If you prefer not to use the mixin, the policy class can be added to permission_classes # permission_classes = (ArticleAccessPolicy,) # Helper property here to make get_queryset logic # more explicit @property def access_policy ( self ): return self . permission_classes [ 0 ] # Ensure that current user can only see the models # they are allowed to see def get_queryset ( self ): return self . access_policy . scope_queryset ( self . request , Articles . objects . all () ) @action ( methods = [ 'POST' ], detail = False ) def publish ( self , request , * args , ** kwargs ): pass @action ( methods = [ 'POST' ], detail = False ) def unpublish ( self , request , * args , ** kwargs ): pass # the rest of you view set definition...","title":"Policy for ViewSet"}]}